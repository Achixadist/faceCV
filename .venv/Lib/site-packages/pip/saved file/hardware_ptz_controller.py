import cv2
import numpy as np
import time
import os
import requests
import urllib.parse
import socket
import threading


class HardwarePTZController:
    """Controller class for camera PTZ features using hardware control protocols"""

    def __init__(self, cap, camera_id=0, camera_ip=None, protocol="auto"):
        self.cap = cap
        self.camera_id = camera_id
        self.camera_ip = camera_ip
        self.protocol = protocol.lower()  # auto, visca, onvif, or pelco

        # Current camera state
        self.current_zoom = 1.0
        self.current_pan = 0.0
        self.current_tilt = 0.0

        # Target zoom/pan/tilt for smoother transitions
        self.target_zoom = 1.0
        self.target_pan = 0.0
        self.target_tilt = 0.0

        # Zoom transition variables
        self.is_zooming = False
        self.zoom_start_time = 0
        self.zoom_duration = 0.6
        self.zoom_start_value = 1.0
        self.zoom_end_value = 1.0

        # Add VISCA port for UDP communication
        self.visca_port = 52381  # Default VISCA over IP port
        self.visca_ip = camera_ip

        # Initialize camera properties
        self._init_camera_properties()

        # Try to determine camera protocol and initialize appropriate controller
        self.ptz_initialized = self._initialize_ptz_protocol()
        if self.ptz_initialized:
            print(f"Hardware PTZ initialized using {self.protocol} protocol")
            self.zoom_thread_running = True
            self.zoom_thread = threading.Thread(target=self._smooth_zoom_thread)
            self.zoom_thread.daemon = True
            self.zoom_thread.start()
        else:
            print("WARNING: Hardware PTZ initialization failed. Falling back to software PTZ.")
            # Keep track of whether we're using hardware or software PTZ
            self.using_hardware_ptz = False

            # Cache for processed frames (only used in software fallback mode)
            self.last_params = None
            self.last_frame = None

    def _init_camera_properties(self):
        """Initialize camera properties and settings"""
        try:
            # Get actual resolution
            self.original_width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            self.original_height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            print(f"Camera resolution: {self.original_width}x{self.original_height}")

            # Default center position
            self.center_x = self.original_width // 2
            self.center_y = self.original_height // 2

            # Set pan and tilt bounds based on frame size (for software fallback)
            self.max_pan_displacement = self.original_width // 6
            self.max_tilt_displacement = self.original_height // 6

            return True
        except Exception as e:
            print(f"Error initializing camera properties: {e}")
            return False

    def _initialize_ptz_protocol(self):
        """Detect and initialize appropriate PTZ protocol based on camera"""
        if self.protocol == "auto":
            # Try to auto-detect the protocol
            protocols_to_try = ["onvif", "visca", "pelco"]

            for protocol in protocols_to_try:
                print(f"Trying {protocol.upper()} protocol...")
                self.protocol = protocol
                if self._setup_protocol_controller():
                    print(f"Successfully detected and initialized {protocol.upper()} protocol")
                    self.using_hardware_ptz = True
                    return True

            print("Could not auto-detect PTZ protocol. Falling back to software PTZ.")
            return False
        else:
            # Use the specified protocol
            success = self._setup_protocol_controller()
            self.using_hardware_ptz = success
            return success

    def _setup_protocol_controller(self):
        """Set up the appropriate protocol controller based on selected protocol"""
        try:
            if self.protocol == "onvif":
                return self._setup_onvif()
            elif self.protocol == "visca":
                return self._setup_visca()
            elif self.protocol == "pelco":
                return self._setup_pelco()
            else:
                print(f"Unsupported protocol: {self.protocol}")
                return False
        except Exception as e:
            print(f"Error setting up {self.protocol} protocol: {e}")
            return False

    def _setup_onvif(self):
        """Set up ONVIF protocol controller"""
        try:
            # If camera IP is not provided, try to determine it from camera index
            if not self.camera_ip:
                print("Error: Camera IP is required for ONVIF protocol")
                return False

            test_url = f"http://{self.camera_ip}/onvif/device_service"
            try:
                response = requests.get(test_url, timeout=2)
                if response.status_code == 200 or response.status_code == 401:
                    print("ONVIF service found")
                    # Store ONVIF parameters
                    self.onvif_username = "admin"
                    self.onvif_password = "admin"
                    self.onvif_port = 80
                    self.onvif_url = f"http://{self.camera_ip}:{self.onvif_port}/onvif/ptz_service"
                    return True
                else:
                    print(f"ONVIF service test failed: {response.status_code}")
                    return False
            except requests.exceptions.RequestException as e:
                print(f"ONVIF connection test failed: {e}")
                return False

        except Exception as e:
            print(f"Error initializing ONVIF protocol: {e}")
            return False

    def _setup_visca(self):
        """Set up VISCA protocol controller"""
        try:
            if not self.camera_ip:
                print("Error: Camera IP is required for VISCA protocol")
                return False

            print(f"Setting up VISCA over IP for camera at {self.camera_ip}")

            # Create UDP socket with error handling
            try:
                self.visca_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                self.visca_socket.settimeout(1)

                print(f"VISCA socket created, assuming camera supports VISCA protocol")
                return True
            except Exception as e:
                print(f"VISCA socket error: {e}")
                return False
        except Exception as e:
            print(f"Error initializing VISCA protocol: {e}")
            return False

    def _setup_pelco(self):
        """Set up Pelco protocol controller"""
        try:
            if self.camera_ip:
                print(f"Setting up Pelco protocol for camera at {self.camera_ip}")
                print("Pelco protocol not implemented yet")
                return False
            else:
                print("Error: Camera IP is required for Pelco protocol")
                return False
        except Exception as e:
            print(f"Error initializing Pelco protocol: {e}")
            return False

    def _smooth_zoom_thread(self):
        """Background thread for smoother zoom transitions"""
        while self.zoom_thread_running:
            try:
                if self.is_zooming:
                    current_time = time.time()
                    elapsed = current_time - self.zoom_start_time
                    progress = min(1.0, elapsed / self.zoom_duration)

                    if progress < 0.5:
                        t = 2.0 * progress * progress
                    else:
                        t = -1.0 + (4.0 - 2.0 * progress) * progress

                    intermediate_zoom = self.zoom_start_value + t * (self.zoom_end_value - self.zoom_start_value)

                    if self.protocol == "visca":
                        self._visca_direct_zoom(intermediate_zoom)
                    elif self.protocol == "onvif":
                        self._onvif_direct_zoom(intermediate_zoom)

                    self.current_zoom = intermediate_zoom

                    if progress >= 1.0:
                        self.is_zooming = False
                        self.current_zoom = self.zoom_end_value
                        if self.protocol == "visca":
                            self._visca_direct_zoom(self.zoom_end_value)

                # Sleep briefly to limit CPU usage
                time.sleep(0.03)
            except Exception as e:
                print(f"Error in zoom thread: {e}")
                time.sleep(0.1)

    def zoom(self, zoom_factor):
        """Control camera zoom

        Args:
            zoom_factor: Zoom level from 1.0 to 4.0
        """
        zoom_factor = max(1.0, min(4.0, zoom_factor))

        if abs(zoom_factor - self.current_zoom) < 0.03:
            return True

        if self.using_hardware_ptz:
            # Set up a smooth transition to the new zoom level
            try:
                self.zoom_start_value = self.current_zoom
                self.zoom_end_value = zoom_factor
                self.zoom_start_time = time.time()

                zoom_distance = abs(self.zoom_end_value - self.zoom_start_value)
                self.zoom_duration = min(0.8, max(0.2, zoom_distance * 0.8))

                self.is_zooming = True
                return True
            except Exception as e:
                print(f"Error sending zoom command: {e}")
                self.using_hardware_ptz = False
                print("Falling back to software PTZ for zoom")
        else:
            self.current_zoom = zoom_factor

        self.last_params = None
        self.last_frame = None
        return True

    def _visca_direct_zoom(self, zoom_value):
        """Send a direct zoom position command using VISCA protocol"""
        try:
            if zoom_value > self.current_zoom:
                # Zoom in
                zoom_speed = min(int((zoom_value - self.current_zoom) * 7), 7)
                cmd = bytes([0x81, 0x01, 0x04, 0x07, zoom_speed, 0xFF])
            elif zoom_value < self.current_zoom:
                # Zoom out
                zoom_speed = min(int((self.current_zoom - zoom_value) * 7), 7)
                cmd = bytes([0x81, 0x01, 0x04, 0x08, zoom_speed, 0xFF])
            else:
                # Stop zoom
                cmd = bytes([0x81, 0x01, 0x04, 0x00, 0xFF])

            print(f"Sending VISCA zoom command: {cmd.hex()}")

            if hasattr(self, 'visca_socket'):
                self.visca_socket.sendto(cmd, (self.camera_ip, self.visca_port))

            return True
        except Exception as e:
            print(f"Error in direct VISCA zoom: {e}")
            return False
    def _onvif_direct_zoom(self, zoom_value):
        """Send a direct zoom position command using ONVIF protocol"""
        try:
            onvif_zoom = (zoom_value - 1.0) / 3.0

            print(f"ONVIF: Setting zoom to {onvif_zoom:.2f}")

            return True
        except Exception as e:
            print(f"Error in direct ONVIF zoom: {e}")
            return False

    def pan_tilt(self, pan, tilt):
        """Control camera pan and tilt

        Args:
            pan: Pan value between -1.0 and 1.0 (negative is left, positive is right)
            tilt: Tilt value between -1.0 and 1.0 (negative is down, positive is up)
        """
        pan = max(-1.0, min(1.0, pan))
        tilt = max(-1.0, min(1.0, tilt))

        self.target_pan = pan
        self.target_tilt = tilt

        if self.using_hardware_ptz:
            try:
                if self.protocol == "visca":
                    return self._visca_pan_tilt(pan, tilt)
                elif self.protocol == "onvif":
                    return self._onvif_pan_tilt(pan, tilt)
                else:
                    print(f"Pan/tilt not supported for {self.protocol} protocol")
                    return False
            except Exception as e:
                print(f"Error sending pan/tilt command: {e}")
                self.using_hardware_ptz = False
                print("Falling back to software PTZ for pan/tilt")

        self.current_pan = pan
        self.current_tilt = tilt

        self.last_params = None
        self.last_frame = None
        return True

    def reset_position(self):
        """Reset camera to default position"""
        print("Resetting camera position...")

        self.current_zoom = 1.0
        self.current_pan = 0.0
        self.current_tilt = 0.0
        self.target_zoom = 1.0
        self.target_pan = 0.0
        self.target_tilt = 0.0

        if self.using_hardware_ptz:
            try:
                if self.protocol == "visca":
                    cmd = bytes([0x81, 0x01, 0x06, 0x04, 0xFF])

                    if hasattr(self, 'visca_socket'):
                        self.visca_socket.sendto(cmd, (self.camera_ip, self.visca_port))

                    return True
                elif self.protocol == "onvif":
                    print("ONVIF: Resetting position")
                    return True
            except Exception as e:
                print(f"Error resetting position: {e}")

        self.last_params = None
        self.last_frame = None
        return True

    def _visca_pan_tilt(self, pan, tilt):
        """Send pan and tilt commands using VISCA protocol"""
        try:
            pan_speed = min(int(abs(pan) * 24), 24)
            tilt_speed = min(int(abs(tilt) * 24), 24)

            # Stop if speed is too low
            if pan_speed < 1 and tilt_speed < 1:
                cmd = bytes([0x81, 0x01, 0x06, 0x01, 0x00, 0x00, 0x03, 0x03, 0xFF])

                if hasattr(self, 'visca_socket'):
                    self.visca_socket.sendto(cmd, (self.camera_ip, self.visca_port))
                return True

            # Determine direction
            if pan > 0:
                pan_dir = 0x02  # Right
            elif pan < 0:
                pan_dir = 0x01  # Left
            else:
                pan_dir = 0x03  # Stop

            if tilt > 0:
                tilt_dir = 0x01  # Up
            elif tilt < 0:
                tilt_dir = 0x02  # Down
            else:
                tilt_dir = 0x03  # Stop

            # Send pan/tilt command
            cmd = bytes([0x81, 0x01, 0x06, 0x01, pan_speed, tilt_speed, pan_dir, tilt_dir, 0xFF])

            if hasattr(self, 'visca_socket'):
                self.visca_socket.sendto(cmd, (self.camera_ip, self.visca_port))

            return True
        except Exception as e:
            print(f"Error in VISCA pan/tilt: {e}")
            return False

    def _onvif_pan_tilt(self, pan, tilt):
        """Send pan and tilt commands using ONVIF protocol"""
        try:
            print(f"ONVIF: Setting pan/tilt to ({pan:.2f}, {tilt:.2f})")
            return True
        except Exception as e:
            print(f"Error in ONVIF pan/tilt: {e}")
            return False

    def micro_pan_tilt(self, pan, tilt):
        """Apply small pan and tilt adjustments

        Args:
            pan: Pan value between -1.0 and 1.0 (negative is left, positive is right)
            tilt: Tilt value between -1.0 and 1.0 (negative is down, positive is up)
        """
        pan = max(-1.0, min(1.0, pan))
        tilt = max(-1.0, min(1.0, tilt))

        self.current_pan += pan * 0.1
        self.current_tilt += tilt * 0.1

        self.current_pan = max(-1.0, min(1.0, self.current_pan))
        self.current_tilt = max(-1.0, min(1.0, self.current_tilt))

        return self.pan_tilt(self.current_pan, self.current_tilt)

    def process_frame(self, frame):
        """Process frame for software-based PTZ when hardware PTZ is not available

        Args:
            frame: Input frame to process

        Returns:
            Processed frame with PTZ applied
        """
        if self.using_hardware_ptz:
            return frame

        current_params = (self.current_zoom, self.current_pan, self.current_tilt)
        if self.last_params == current_params and self.last_frame is not None:
            return self.last_frame

        self.last_params = current_params

        height, width = frame.shape[:2]

        zoom = self.current_zoom

        crop_width = int(width / zoom)
        crop_height = int(height / zoom)

        pan_offset = int(self.current_pan * (width - crop_width) / 2)
        tilt_offset = int(self.current_tilt * (height - crop_height) / 2)

        x1 = (width - crop_width) // 2 + pan_offset
        y1 = (height - crop_height) // 2 + tilt_offset
        x2 = x1 + crop_width
        y2 = y1 + crop_height

        x1 = max(0, min(width - 2, x1))
        y1 = max(0, min(height - 2, y1))
        x2 = max(x1 + 1, min(width, x2))
        y2 = max(y1 + 1, min(height, y2))

        cropped = frame[y1:y2, x1:x2]

        result = cv2.resize(cropped, (width, height), interpolation=cv2.INTER_LINEAR)

        self.last_frame = result

        return result

    def get_current_zoom(self):
        """Get current zoom level"""
        return self.current_zoom

    def get_current_pan_tilt(self):
        """Get current pan/tilt values as a tuple (pan, tilt)"""
        return (self.current_pan, self.current_tilt)

    def close(self):
        """Clean up resources"""
        if hasattr(self, 'zoom_thread_running'):
            self.zoom_thread_running = False
            if hasattr(self, 'zoom_thread') and self.zoom_thread.is_alive():
                self.zoom_thread.join(timeout=1.0)

        if hasattr(self, 'visca_socket'):
            try:
                self.visca_socket.close()
            except:
                pass