import cv2
import numpy as np
import time
import os
import requests
import urllib.parse
import socket
import threading


class HardwarePTZController:
    """Controller class for camera PTZ features using hardware control protocols"""

    def __init__(self, cap, camera_id=0, camera_ip=None, protocol="auto"):
        self.cap = cap
        self.camera_id = camera_id
        self.camera_ip = camera_ip
        self.protocol = protocol.lower()  # auto, visca, onvif, or pelco

        # Current camera state
        self.current_zoom = 1.0
        self.current_pan = 0.0  # -1.0 (left) to 1.0 (right)
        self.current_tilt = 0.0  # -1.0 (down) to 1.0 (up)

        # Target zoom/pan/tilt for smoother transitions
        self.target_zoom = 1.0
        self.target_pan = 0.0
        self.target_tilt = 0.0

        # Zoom transition variables - MODIFIED for more responsive zooming
        self.is_zooming = False
        self.zoom_start_time = 0
        self.zoom_duration = 0.6  # Reduced from 1.0 for faster zoom transitions
        self.zoom_start_value = 1.0
        self.zoom_end_value = 1.0

        # Add VISCA port for UDP communication
        self.visca_port = 52381  # Default VISCA over IP port
        self.visca_ip = camera_ip

        # Initialize camera properties
        self._init_camera_properties()

        # Try to determine camera protocol and initialize appropriate controller
        self.ptz_initialized = self._initialize_ptz_protocol()
        if self.ptz_initialized:
            print(f"Hardware PTZ initialized using {self.protocol} protocol")
            # Start a thread for smooth zoom transitions if using hardware PTZ
            self.zoom_thread_running = True
            self.zoom_thread = threading.Thread(target=self._smooth_zoom_thread)
            self.zoom_thread.daemon = True
            self.zoom_thread.start()
        else:
            print("WARNING: Hardware PTZ initialization failed. Falling back to software PTZ.")
            # Keep track of whether we're using hardware or software PTZ
            self.using_hardware_ptz = False

            # Cache for processed frames (only used in software fallback mode)
            self.last_params = None
            self.last_frame = None

    def _init_camera_properties(self):
        """Initialize camera properties and settings"""
        try:
            # Get actual resolution
            self.original_width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            self.original_height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            print(f"Camera resolution: {self.original_width}x{self.original_height}")

            # Default center position
            self.center_x = self.original_width // 2
            self.center_y = self.original_height // 2

            # Set pan and tilt bounds based on frame size (for software fallback)
            self.max_pan_displacement = self.original_width // 6
            self.max_tilt_displacement = self.original_height // 6

            return True
        except Exception as e:
            print(f"Error initializing camera properties: {e}")
            return False

    def _initialize_ptz_protocol(self):
        """Detect and initialize appropriate PTZ protocol based on camera"""
        if self.protocol == "auto":
            # Try to auto-detect the protocol
            protocols_to_try = ["onvif", "visca", "pelco"]

            for protocol in protocols_to_try:
                print(f"Trying {protocol.upper()} protocol...")
                self.protocol = protocol
                if self._setup_protocol_controller():
                    print(f"Successfully detected and initialized {protocol.upper()} protocol")
                    self.using_hardware_ptz = True
                    return True

            print("Could not auto-detect PTZ protocol. Falling back to software PTZ.")
            return False
        else:
            # Use the specified protocol
            success = self._setup_protocol_controller()
            self.using_hardware_ptz = success
            return success

    def _setup_protocol_controller(self):
        """Set up the appropriate protocol controller based on selected protocol"""
        try:
            if self.protocol == "onvif":
                return self._setup_onvif()
            elif self.protocol == "visca":
                return self._setup_visca()
            elif self.protocol == "pelco":
                return self._setup_pelco()
            else:
                print(f"Unsupported protocol: {self.protocol}")
                return False
        except Exception as e:
            print(f"Error setting up {self.protocol} protocol: {e}")
            return False

    def _setup_onvif(self):
        """Set up ONVIF protocol controller"""
        try:
            # If camera IP is not provided, try to determine it from camera index
            if not self.camera_ip:
                # This is a simplified approach - in reality, discovering IP is more complex
                # You may need to use a network scanning tool or know the camera's IP beforehand
                print("Error: Camera IP is required for ONVIF protocol")
                return False

            # For ONVIF, we'd typically use a library like python-onvif or onvif-zeep-async
            # For simplicity, we'll use direct HTTP requests to the ONVIF endpoints

            # Test connection to camera's ONVIF service
            test_url = f"http://{self.camera_ip}/onvif/device_service"
            try:
                response = requests.get(test_url, timeout=2)
                if response.status_code == 200 or response.status_code == 401:  # 401 means auth required but service exists
                    print("ONVIF service found")
                    # Store ONVIF parameters
                    self.onvif_username = "admin"  # Default username - should be configurable
                    self.onvif_password = "admin"  # Default password - should be configurable
                    self.onvif_port = 80  # Default port - should be configurable
                    self.onvif_url = f"http://{self.camera_ip}:{self.onvif_port}/onvif/ptz_service"
                    return True
                else:
                    print(f"ONVIF service test failed: {response.status_code}")
                    return False
            except requests.exceptions.RequestException as e:
                print(f"ONVIF connection test failed: {e}")
                return False

        except Exception as e:
            print(f"Error initializing ONVIF protocol: {e}")
            return False

    def _setup_visca(self):
        """Set up VISCA protocol controller"""
        try:
            if not self.camera_ip:
                print("Error: Camera IP is required for VISCA protocol")
                return False

            print(f"Setting up VISCA over IP for camera at {self.camera_ip}")

            # Create UDP socket with error handling
            try:
                self.visca_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                self.visca_socket.settimeout(1)  # Ensure socket operations don't block forever

                # Don't try to connect or verify - VISCA UDP doesn't require connection
                print(f"VISCA socket created, assuming camera supports VISCA protocol")
                return True
            except Exception as e:
                print(f"VISCA socket error: {e}")
                return False
        except Exception as e:
            print(f"Error initializing VISCA protocol: {e}")
            return False

    def _setup_pelco(self):
        """Set up Pelco protocol controller"""
        try:
            if self.camera_ip:
                print(f"Setting up Pelco protocol for camera at {self.camera_ip}")
                # Implement Pelco protocol setup here
                # For now, just return False as not implemented
                print("Pelco protocol not implemented yet")
                return False
            else:
                print("Error: Camera IP is required for Pelco protocol")
                return False
        except Exception as e:
            print(f"Error initializing Pelco protocol: {e}")
            return False

    def _smooth_zoom_thread(self):
        """Background thread for smoother zoom transitions"""
        while self.zoom_thread_running:
            try:
                if self.is_zooming:
                    current_time = time.time()
                    elapsed = current_time - self.zoom_start_time
                    progress = min(1.0, elapsed / self.zoom_duration)

                    # Equal easing for zoom in/out
                    if progress < 0.5:
                        # Ease in (accelerate)
                        t = 2.0 * progress * progress
                    else:
                        # Ease out (decelerate)
                        t = -1.0 + (4.0 - 2.0 * progress) * progress

                    # Calculate intermediate zoom value
                    intermediate_zoom = self.zoom_start_value + t * (self.zoom_end_value - self.zoom_start_value)

                    # Apply the actual zoom command
                    if self.protocol == "visca":
                        self._visca_direct_zoom(intermediate_zoom)
                    elif self.protocol == "onvif":
                        self._onvif_direct_zoom(intermediate_zoom)

                    # Update current zoom
                    self.current_zoom = intermediate_zoom

                    # Check if we're done
                    if progress >= 1.0:
                        self.is_zooming = False
                        self.current_zoom = self.zoom_end_value
                        # Send a final command with the exact target value
                        if self.protocol == "visca":
                            self._visca_direct_zoom(self.zoom_end_value)

                # Sleep briefly to limit CPU usage
                time.sleep(0.03)
            except Exception as e:
                print(f"Error in zoom thread: {e}")
                time.sleep(0.1)

    def zoom(self, zoom_factor):
        """Control camera zoom

        Args:
            zoom_factor: Zoom level from 1.0 to 4.0
        """
        # Store requested zoom factor
        zoom_factor = max(1.0, min(4.0, zoom_factor))

        # MODIFIED: Reduced threshold for minimal changes
        if abs(zoom_factor - self.current_zoom) < 0.03:  # Changed from 0.05
            return True

        if self.using_hardware_ptz:
            # Set up a smooth transition to the new zoom level
            try:
                self.zoom_start_value = self.current_zoom
                self.zoom_end_value = zoom_factor
                self.zoom_start_time = time.time()

                # Adjust duration based on zoom distance (shorter for small changes)
                zoom_distance = abs(self.zoom_end_value - self.zoom_start_value)
                # MODIFIED: Made duration shorter for faster zooming
                self.zoom_duration = min(0.8, max(0.2, zoom_distance * 0.8))

                # Start the zoom transition
                self.is_zooming = True
                return True
            except Exception as e:
                print(f"Error sending zoom command: {e}")
                # Fall back to software zoom on error
                self.using_hardware_ptz = False
                print("Falling back to software PTZ for zoom")
        else:
            # For software fallback, just update the current zoom
            self.current_zoom = zoom_factor

        # Software fallback
        # Reset cached frame when zoom changes
        self.last_params = None
        self.last_frame = None
        return True

    # Replace the current _visca_direct_zoom method with this corrected version
    def _visca_direct_zoom(self, zoom_value):
        """Send a direct zoom position command using VISCA protocol"""
        try:
            # Convert zoom_value (1.0-4.0) to zoom speed (0-7)
            if zoom_value > self.current_zoom:
                # Zoom in
                zoom_speed = min(int((zoom_value - self.current_zoom) * 7), 7)
                cmd = bytes([0x81, 0x01, 0x04, 0x07, zoom_speed, 0xFF])  # Zoom tele with speed
            elif zoom_value < self.current_zoom:
                # Zoom out
                zoom_speed = min(int((self.current_zoom - zoom_value) * 7), 7)
                cmd = bytes([0x81, 0x01, 0x04, 0x08, zoom_speed, 0xFF])  # Zoom wide with speed
            else:
                # Stop zoom
                cmd = bytes([0x81, 0x01, 0x04, 0x00, 0xFF])  # Stop zoom

            print(f"Sending VISCA zoom command: {cmd.hex()}")

            if hasattr(self, 'visca_socket'):
                self.visca_socket.sendto(cmd, (self.camera_ip, self.visca_port))

            return True
        except Exception as e:
            print(f"Error in direct VISCA zoom: {e}")
            return False
    def _onvif_direct_zoom(self, zoom_value):
        """Send a direct zoom position command using ONVIF protocol"""
        try:
            # Convert zoom_factor (1.0-4.0) to ONVIF zoom value (typically 0.0-1.0)
            onvif_zoom = (zoom_value - 1.0) / 3.0

            # In real implementation, would use ONVIF library to set absolute position
            # This is a simplified placeholder
            print(f"ONVIF: Setting zoom to {onvif_zoom:.2f}")

            return True
        except Exception as e:
            print(f"Error in direct ONVIF zoom: {e}")
            return False

    def pan_tilt(self, pan, tilt):
        """Control camera pan and tilt

        Args:
            pan: Pan value between -1.0 and 1.0 (negative is left, positive is right)
            tilt: Tilt value between -1.0 and 1.0 (negative is down, positive is up)
        """
        # Ensure values are within valid range
        pan = max(-1.0, min(1.0, pan))
        tilt = max(-1.0, min(1.0, tilt))

        # Update target values
        self.target_pan = pan
        self.target_tilt = tilt

        if self.using_hardware_ptz:
            try:
                if self.protocol == "visca":
                    return self._visca_pan_tilt(pan, tilt)
                elif self.protocol == "onvif":
                    return self._onvif_pan_tilt(pan, tilt)
                else:
                    print(f"Pan/tilt not supported for {self.protocol} protocol")
                    return False
            except Exception as e:
                print(f"Error sending pan/tilt command: {e}")
                # Fall back to software PTZ on error
                self.using_hardware_ptz = False
                print("Falling back to software PTZ for pan/tilt")

        # Update current values directly for software fallback
        self.current_pan = pan
        self.current_tilt = tilt

        # Reset cached frame when pan/tilt changes
        self.last_params = None
        self.last_frame = None
        return True

    def reset_position(self):
        """Reset camera to default position"""
        print("Resetting camera position...")

        # Reset internal state
        self.current_zoom = 1.0
        self.current_pan = 0.0
        self.current_tilt = 0.0
        self.target_zoom = 1.0
        self.target_pan = 0.0
        self.target_tilt = 0.0

        if self.using_hardware_ptz:
            try:
                if self.protocol == "visca":
                    # VISCA reset command
                    cmd = bytes([0x81, 0x01, 0x06, 0x04, 0xFF])

                    if hasattr(self, 'visca_socket'):
                        self.visca_socket.sendto(cmd, (self.camera_ip, self.visca_port))

                    return True
                elif self.protocol == "onvif":
                    # ONVIF reset command would go here
                    print("ONVIF: Resetting position")
                    return True
            except Exception as e:
                print(f"Error resetting position: {e}")

        # Reset cached frame
        self.last_params = None
        self.last_frame = None
        return True

    def _visca_pan_tilt(self, pan, tilt):
        """Send pan and tilt commands using VISCA protocol"""
        try:
            # Convert pan/tilt values (-1.0 to 1.0) to VISCA speed values (0 to 24)
            # 0-7 is slow, 8-15 is medium, 16-24 is fast
            # Calculate the pan/tilt speed based on how far we are from center

            # MODIFIED: Made panning and tilting more responsive
            pan_speed = min(int(abs(pan) * 24), 24)
            tilt_speed = min(int(abs(tilt) * 24), 24)

            # Stop if speed is too low
            if pan_speed < 1 and tilt_speed < 1:
                cmd = bytes([0x81, 0x01, 0x06, 0x01, 0x00, 0x00, 0x03, 0x03, 0xFF])

                if hasattr(self, 'visca_socket'):
                    self.visca_socket.sendto(cmd, (self.camera_ip, self.visca_port))
                return True

            # Determine direction
            if pan > 0:
                pan_dir = 0x02  # Right
            elif pan < 0:
                pan_dir = 0x01  # Left
            else:
                pan_dir = 0x03  # Stop

            if tilt > 0:
                tilt_dir = 0x01  # Up
            elif tilt < 0:
                tilt_dir = 0x02  # Down
            else:
                tilt_dir = 0x03  # Stop

            # Send pan/tilt command
            cmd = bytes([0x81, 0x01, 0x06, 0x01, pan_speed, tilt_speed, pan_dir, tilt_dir, 0xFF])

            if hasattr(self, 'visca_socket'):
                self.visca_socket.sendto(cmd, (self.camera_ip, self.visca_port))

            return True
        except Exception as e:
            print(f"Error in VISCA pan/tilt: {e}")
            return False

    def _onvif_pan_tilt(self, pan, tilt):
        """Send pan and tilt commands using ONVIF protocol"""
        try:
            # Convert values to ONVIF range
            # This is a simplified placeholder - real implementation would use ONVIF API
            print(f"ONVIF: Setting pan/tilt to ({pan:.2f}, {tilt:.2f})")
            return True
        except Exception as e:
            print(f"Error in ONVIF pan/tilt: {e}")
            return False

    def micro_pan_tilt(self, pan, tilt):
        """Apply small pan and tilt adjustments

        Args:
            pan: Pan value between -1.0 and 1.0 (negative is left, positive is right)
            tilt: Tilt value between -1.0 and 1.0 (negative is down, positive is up)
        """
        # Ensure pan/tilt values are within valid range
        pan = max(-1.0, min(1.0, pan))
        tilt = max(-1.0, min(1.0, tilt))

        # Update current pan/tilt values (accumulate changes)
        # MODIFIED: Increased the factor from 0.05 to 0.1 for more responsive micro adjustments
        self.current_pan += pan * 0.1
        self.current_tilt += tilt * 0.1

        # Limit to allowed range
        self.current_pan = max(-1.0, min(1.0, self.current_pan))
        self.current_tilt = max(-1.0, min(1.0, self.current_tilt))

        # Apply the pan/tilt command
        return self.pan_tilt(self.current_pan, self.current_tilt)

    def process_frame(self, frame):
        """Process frame for software-based PTZ when hardware PTZ is not available

        Args:
            frame: Input frame to process

        Returns:
            Processed frame with PTZ applied
        """
        if self.using_hardware_ptz:
            # No need to process frame if using hardware PTZ
            return frame

        # Check if params have changed
        current_params = (self.current_zoom, self.current_pan, self.current_tilt)
        if self.last_params == current_params and self.last_frame is not None:
            return self.last_frame

        # Store current parameters
        self.last_params = current_params

        # Get frame dimensions
        height, width = frame.shape[:2]

        # Calculate zoom and pan/tilt transformations
        # For zoom, we'll use a center crop that gets smaller as zoom increases
        zoom = self.current_zoom

        # Calculate the size of the cropped region (smaller means more zoom)
        crop_width = int(width / zoom)
        crop_height = int(height / zoom)

        # Calculate pan/tilt offsets
        # Panning moves the crop region left/right, tilting moves it up/down
        # The displacement is proportional to the remaining margin after cropping
        pan_offset = int(self.current_pan * (width - crop_width) / 2)
        tilt_offset = int(self.current_tilt * (height - crop_height) / 2)

        # Calculate the crop region
        x1 = (width - crop_width) // 2 + pan_offset
        y1 = (height - crop_height) // 2 + tilt_offset
        x2 = x1 + crop_width
        y2 = y1 + crop_height

        # Ensure crop region stays within frame bounds
        x1 = max(0, min(width - 2, x1))
        y1 = max(0, min(height - 2, y1))
        x2 = max(x1 + 1, min(width, x2))
        y2 = max(y1 + 1, min(height, y2))

        # Crop the region
        cropped = frame[y1:y2, x1:x2]

        # Resize back to original size
        result = cv2.resize(cropped, (width, height), interpolation=cv2.INTER_LINEAR)

        # Cache the processed frame
        self.last_frame = result

        return result

    def get_current_zoom(self):
        """Get current zoom level"""
        return self.current_zoom

    def get_current_pan_tilt(self):
        """Get current pan/tilt values as a tuple (pan, tilt)"""
        return (self.current_pan, self.current_tilt)

    def close(self):
        """Clean up resources"""
        if hasattr(self, 'zoom_thread_running'):
            self.zoom_thread_running = False
            if hasattr(self, 'zoom_thread') and self.zoom_thread.is_alive():
                self.zoom_thread.join(timeout=1.0)

        if hasattr(self, 'visca_socket'):
            try:
                self.visca_socket.close()
            except:
                pass